import{S as Fs,i as Gs,s as Ks,k as o,r as n,a as u,l as p,m as l,u as a,h as s,c as h,p as r,b as i,M as t,n as ds}from"./index.26320ab0.js";function Qs(Us){let y,_e,_,U,oe,k,ge,$,xe,je,B,Se,Pe,pe,g,Ce,x,W,le,m,Te,j,Ae,Me,L,Je,De,ce,S,$s=`<code class="language-typescript"><span class="token keyword">readonly</span> queryJobStatus <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>jobId$<span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> jobId$<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
    <span class="token function">switchMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>jobId<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>jobService<span class="token punctuation">.</span><span class="token function">getJobStatus</span><span class="token punctuation">(</span>jobId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
        <span class="token generic-function"><span class="token function">pollUntil</span><span class="token generic class-name"><span class="token operator">&lt;</span>JobCreationResponse<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">3_000</span><span class="token punctuation">,</span> pollUntilPredicateHandler<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">tapResponse</span><span class="token punctuation">(</span>
          <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleJobComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">(</span>error<span class="token operator">:</span> HttpErrorResponse<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleJobError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,ie,D,Oe,re,O,Y,Re,ue,P,qe,C,z,he,T,Bs=`<code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pollUntil</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pollInterval<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token function-variable function">responsePredicate</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>source$<span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">timer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> pollInterval<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
      <span class="token function">switchMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> source$<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">first</span><span class="token punctuation">(</span>responsePredicate<span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,de,f,He,F,Ne,Ue,G,$e,Be,K,We,Le,fe,v,Ye,Q,ze,Fe,ke,A,Ws=`<code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pollUntilPredicateHandler</span><span class="token punctuation">(</span>response<span class="token operator">:</span> PollingOperationResponseData<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> AsyncJobState<span class="token punctuation">.</span>completed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// success - stop polling</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> AsyncJobState<span class="token punctuation">.</span>failed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>$localize<span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">Job failed.</span><span class="token template-punctuation string">&#96;</span></span><span class="token punctuation">)</span> <span class="token comment">// error - stop polling</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// continue polling</span>
<span class="token punctuation">&#125;</span></code>`,me,E,Ge,V,Ke,Qe,be,R,Ve,we,M,Xe,J,X,ye,b,Ze,Z,es,ss,ee,ts,ns,ve,d,as,se,os,ps,te,ls,cs,ne,is,rs,ae,us,hs;return{c(){y=o("h3"),_e=n("The Context"),_=o("a"),U=o("span"),oe=u(),k=o("p"),ge=n("In a SaaS product I work on, we allow users to perform actions on a large data set. Naturally, such processing can sometimes take a while and we do not want our users held up by a long-running request. So, I send a request with a filter object denoting which items in the data set should be processed, a job gets created, and a "),$=o("code"),xe=n("jobId"),je=n(" is returned. I use that "),B=o("code"),Se=n("jobId"),Pe=n(" to poll an endpoint every few seconds to get the status of the job. If the job status is “pending” or “in_progress”, I continue polling. If it fails, I stop polling and display an error message. If it completes successfully, I show a quick “snackbar” message to the user that the job has completed."),pe=u(),g=o("h3"),Ce=n("The Usage"),x=o("a"),W=o("span"),le=u(),m=o("p"),Te=n("I am a big fan of "),j=o("a"),Ae=n("NgRx Component Store"),Me=n(" and use it extensively in my projects. In the example below, you can see I consume the custom "),L=o("code"),Je=n("pollUntil"),De=n(" operator just like any other “pipeable” RxJS operator."),ce=u(),S=o("pre"),ie=u(),D=o("p"),Oe=n("Note that we can give it an interface that describes the shape of the response, we can specify the polling interval in milliseconds, and we pass in a predicate handler. The predicate handler is what determines when the polling will stop."),re=u(),O=o("p"),Y=o("em"),Re=n("Note: Did you know in modern JS, you can separate numbers with an underscore to make them more readable? In the example above, JS understands 3_000 to be 3000."),ue=u(),P=o("h3"),qe=n("Under the Hood"),C=o("a"),z=o("span"),he=u(),T=o("pre"),de=u(),f=o("p"),He=n("As you can see, I use generics to allow the consumer to specify the type of their source observable and I create a timer that emits on the interval the consumer provides. When the timer emits, the "),F=o("code"),Ne=n("switchMap"),Ue=n(" subscribes to the "),G=o("code"),$e=n("source$"),Be=n(" observable and because our source in this case is a "),K=o("code"),We=n("HttpClient"),Le=n(" request, the request is made each time the timer emits."),fe=u(),v=o("p"),Ye=n("The "),Q=o("code"),ze=n("first"),Fe=n(" RxJS operator emits only the first value that meets the condition specified in the predicate passed into it. You will likely need to write your own predicate here and pass it into the operator because it is specific to your API response. Below is an example of mine."),ke=u(),A=o("pre"),me=u(),E=o("p"),Ge=n("In my predicate, I check to see if the job is complete. If it is, I return "),V=o("code"),Ke=n("true"),Qe=n(" and it completes the observable stream and polling stops. If the job fails, I throw an error, which also completes the observable stream and the polling stops. If I return false, the polling continues."),be=u(),R=o("p"),Ve=n("Note: Because I want this to be reusable, the error message is intentionally vague. Referring back to my first example, it’s up to the consumer to catch the error and handle it respective to each use case."),we=u(),M=o("h3"),Xe=n("Watch out for this"),J=o("a"),X=o("span"),ye=u(),b=o("p"),Ze=n("Notice that the "),Z=o("code"),es=n("pollUntil"),ss=n(" operator uses "),ee=o("code"),ts=n("switchMap"),ns=n(" under the hood. That means if the interval is too short and emits again before we get a response, the previous request will be effectively canceled and the new request will be made. This isn’t a big deal if it happens only rarely, but if your response time is always slower than your interval time, you could find yourself in an infinite loop where polling never stops."),ve=u(),d=o("p"),as=n("Another thing worth noting is that this is intended for “reading” data, not for “writing” data. Because "),se=o("code"),os=n("switchMap"),ps=n(" unsubscribes from the previous inner observable and subscribes to a new inner observable when the source observable emits, you cannot be sure if the “write” actually happened or not. This can cause front-end state and back-end state to get out of sync. A general best practice is to use "),te=o("code"),ls=n("switchMap"),cs=n(" for reads and "),ne=o("code"),is=n("concatMap"),rs=n(" or "),ae=o("code"),us=n("exhaustMap"),hs=n(" for writes."),this.h()},l(e){y=p(e,"H3",{id:!0});var c=l(y);_e=a(c,"The Context"),c.forEach(s),_=p(e,"A",{href:!0});var fs=l(_);U=p(fs,"SPAN",{class:!0}),l(U).forEach(s),fs.forEach(s),oe=h(e),k=p(e,"P",{});var q=l(k);ge=a(q,"In a SaaS product I work on, we allow users to perform actions on a large data set. Naturally, such processing can sometimes take a while and we do not want our users held up by a long-running request. So, I send a request with a filter object denoting which items in the data set should be processed, a job gets created, and a "),$=p(q,"CODE",{});var ks=l($);xe=a(ks,"jobId"),ks.forEach(s),je=a(q," is returned. I use that "),B=p(q,"CODE",{});var ms=l(B);Se=a(ms,"jobId"),ms.forEach(s),Pe=a(q," to poll an endpoint every few seconds to get the status of the job. If the job status is “pending” or “in_progress”, I continue polling. If it fails, I stop polling and display an error message. If it completes successfully, I show a quick “snackbar” message to the user that the job has completed."),q.forEach(s),pe=h(e),g=p(e,"H3",{id:!0});var bs=l(g);Ce=a(bs,"The Usage"),bs.forEach(s),x=p(e,"A",{href:!0});var ws=l(x);W=p(ws,"SPAN",{class:!0}),l(W).forEach(s),ws.forEach(s),le=h(e),m=p(e,"P",{});var H=l(m);Te=a(H,"I am a big fan of "),j=p(H,"A",{href:!0,rel:!0});var ys=l(j);Ae=a(ys,"NgRx Component Store"),ys.forEach(s),Me=a(H," and use it extensively in my projects. In the example below, you can see I consume the custom "),L=p(H,"CODE",{});var vs=l(L);Je=a(vs,"pollUntil"),vs.forEach(s),De=a(H," operator just like any other “pipeable” RxJS operator."),H.forEach(s),ce=h(e),S=p(e,"PRE",{class:!0});var Ls=l(S);Ls.forEach(s),ie=h(e),D=p(e,"P",{});var Es=l(D);Oe=a(Es,"Note that we can give it an interface that describes the shape of the response, we can specify the polling interval in milliseconds, and we pass in a predicate handler. The predicate handler is what determines when the polling will stop."),Es.forEach(s),re=h(e),O=p(e,"P",{});var Is=l(O);Y=p(Is,"EM",{});var _s=l(Y);Re=a(_s,"Note: Did you know in modern JS, you can separate numbers with an underscore to make them more readable? In the example above, JS understands 3_000 to be 3000."),_s.forEach(s),Is.forEach(s),ue=h(e),P=p(e,"H3",{id:!0});var gs=l(P);qe=a(gs,"Under the Hood"),gs.forEach(s),C=p(e,"A",{href:!0});var xs=l(C);z=p(xs,"SPAN",{class:!0}),l(z).forEach(s),xs.forEach(s),he=h(e),T=p(e,"PRE",{class:!0});var Ys=l(T);Ys.forEach(s),de=h(e),f=p(e,"P",{});var I=l(f);He=a(I,"As you can see, I use generics to allow the consumer to specify the type of their source observable and I create a timer that emits on the interval the consumer provides. When the timer emits, the "),F=p(I,"CODE",{});var js=l(F);Ne=a(js,"switchMap"),js.forEach(s),Ue=a(I," subscribes to the "),G=p(I,"CODE",{});var Ss=l(G);$e=a(Ss,"source$"),Ss.forEach(s),Be=a(I," observable and because our source in this case is a "),K=p(I,"CODE",{});var Ps=l(K);We=a(Ps,"HttpClient"),Ps.forEach(s),Le=a(I," request, the request is made each time the timer emits."),I.forEach(s),fe=h(e),v=p(e,"P",{});var Ee=l(v);Ye=a(Ee,"The "),Q=p(Ee,"CODE",{});var Cs=l(Q);ze=a(Cs,"first"),Cs.forEach(s),Fe=a(Ee," RxJS operator emits only the first value that meets the condition specified in the predicate passed into it. You will likely need to write your own predicate here and pass it into the operator because it is specific to your API response. Below is an example of mine."),Ee.forEach(s),ke=h(e),A=p(e,"PRE",{class:!0});var zs=l(A);zs.forEach(s),me=h(e),E=p(e,"P",{});var Ie=l(E);Ge=a(Ie,"In my predicate, I check to see if the job is complete. If it is, I return "),V=p(Ie,"CODE",{});var Ts=l(V);Ke=a(Ts,"true"),Ts.forEach(s),Qe=a(Ie," and it completes the observable stream and polling stops. If the job fails, I throw an error, which also completes the observable stream and the polling stops. If I return false, the polling continues."),Ie.forEach(s),be=h(e),R=p(e,"P",{});var As=l(R);Ve=a(As,"Note: Because I want this to be reusable, the error message is intentionally vague. Referring back to my first example, it’s up to the consumer to catch the error and handle it respective to each use case."),As.forEach(s),we=h(e),M=p(e,"H3",{id:!0});var Ms=l(M);Xe=a(Ms,"Watch out for this"),Ms.forEach(s),J=p(e,"A",{href:!0});var Js=l(J);X=p(Js,"SPAN",{class:!0}),l(X).forEach(s),Js.forEach(s),ye=h(e),b=p(e,"P",{});var N=l(b);Ze=a(N,"Notice that the "),Z=p(N,"CODE",{});var Ds=l(Z);es=a(Ds,"pollUntil"),Ds.forEach(s),ss=a(N," operator uses "),ee=p(N,"CODE",{});var Os=l(ee);ts=a(Os,"switchMap"),Os.forEach(s),ns=a(N," under the hood. That means if the interval is too short and emits again before we get a response, the previous request will be effectively canceled and the new request will be made. This isn’t a big deal if it happens only rarely, but if your response time is always slower than your interval time, you could find yourself in an infinite loop where polling never stops."),N.forEach(s),ve=h(e),d=p(e,"P",{});var w=l(d);as=a(w,"Another thing worth noting is that this is intended for “reading” data, not for “writing” data. Because "),se=p(w,"CODE",{});var Rs=l(se);os=a(Rs,"switchMap"),Rs.forEach(s),ps=a(w," unsubscribes from the previous inner observable and subscribes to a new inner observable when the source observable emits, you cannot be sure if the “write” actually happened or not. This can cause front-end state and back-end state to get out of sync. A general best practice is to use "),te=p(w,"CODE",{});var qs=l(te);ls=a(qs,"switchMap"),qs.forEach(s),cs=a(w," for reads and "),ne=p(w,"CODE",{});var Hs=l(ne);is=a(Hs,"concatMap"),Hs.forEach(s),rs=a(w," or "),ae=p(w,"CODE",{});var Ns=l(ae);us=a(Ns,"exhaustMap"),Ns.forEach(s),hs=a(w," for writes."),w.forEach(s),this.h()},h(){r(y,"id","the-context"),r(U,"class","icon icon-link"),r(_,"href","#the-context"),r(g,"id","the-usage"),r(W,"class","icon icon-link"),r(x,"href","#the-usage"),r(j,"href","https://ngrx.io/guide/component-store"),r(j,"rel","nofollow"),r(S,"class","language-typescript"),r(P,"id","under-the-hood"),r(z,"class","icon icon-link"),r(C,"href","#under-the-hood"),r(T,"class","language-typescript"),r(A,"class","language-typescript"),r(M,"id","watch-out-for-this"),r(X,"class","icon icon-link"),r(J,"href","#watch-out-for-this")},m(e,c){i(e,y,c),t(y,_e),i(e,_,c),t(_,U),i(e,oe,c),i(e,k,c),t(k,ge),t(k,$),t($,xe),t(k,je),t(k,B),t(B,Se),t(k,Pe),i(e,pe,c),i(e,g,c),t(g,Ce),i(e,x,c),t(x,W),i(e,le,c),i(e,m,c),t(m,Te),t(m,j),t(j,Ae),t(m,Me),t(m,L),t(L,Je),t(m,De),i(e,ce,c),i(e,S,c),S.innerHTML=$s,i(e,ie,c),i(e,D,c),t(D,Oe),i(e,re,c),i(e,O,c),t(O,Y),t(Y,Re),i(e,ue,c),i(e,P,c),t(P,qe),i(e,C,c),t(C,z),i(e,he,c),i(e,T,c),T.innerHTML=Bs,i(e,de,c),i(e,f,c),t(f,He),t(f,F),t(F,Ne),t(f,Ue),t(f,G),t(G,$e),t(f,Be),t(f,K),t(K,We),t(f,Le),i(e,fe,c),i(e,v,c),t(v,Ye),t(v,Q),t(Q,ze),t(v,Fe),i(e,ke,c),i(e,A,c),A.innerHTML=Ws,i(e,me,c),i(e,E,c),t(E,Ge),t(E,V),t(V,Ke),t(E,Qe),i(e,be,c),i(e,R,c),t(R,Ve),i(e,we,c),i(e,M,c),t(M,Xe),i(e,J,c),t(J,X),i(e,ye,c),i(e,b,c),t(b,Ze),t(b,Z),t(Z,es),t(b,ss),t(b,ee),t(ee,ts),t(b,ns),i(e,ve,c),i(e,d,c),t(d,as),t(d,se),t(se,os),t(d,ps),t(d,te),t(te,ls),t(d,cs),t(d,ne),t(ne,is),t(d,rs),t(d,ae),t(ae,us),t(d,hs)},p:ds,i:ds,o:ds,d(e){e&&s(y),e&&s(_),e&&s(oe),e&&s(k),e&&s(pe),e&&s(g),e&&s(x),e&&s(le),e&&s(m),e&&s(ce),e&&s(S),e&&s(ie),e&&s(D),e&&s(re),e&&s(O),e&&s(ue),e&&s(P),e&&s(C),e&&s(he),e&&s(T),e&&s(de),e&&s(f),e&&s(fe),e&&s(v),e&&s(ke),e&&s(A),e&&s(me),e&&s(E),e&&s(be),e&&s(R),e&&s(we),e&&s(M),e&&s(J),e&&s(ye),e&&s(b),e&&s(ve),e&&s(d)}}}const Xs={title:"Polling HTTP in Angular with RxJS",date:"2023-10-24",description:"Create a reusable pollUntil operator to poll HTTP endpoints with Angular and RxJS",published:!0,tags:["angular","rxjs"]};class Zs extends Fs{constructor(y){super(),Gs(this,y,null,Qs,Ks,{})}}export{Zs as default,Xs as metadata};
