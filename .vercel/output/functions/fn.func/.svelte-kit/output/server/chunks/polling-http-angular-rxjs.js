import { c as create_ssr_component } from "./index2.js";
const metadata = {
  "title": "Polling HTTP in Angular with RxJS",
  "date": "2023-10-24",
  "description": "Create a reusable pollUntil operator to poll HTTP endpoints with Angular and RxJS",
  "published": true,
  "tags": ["angular", "rxjs"]
};
const Polling_http_angular_rxjs = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h3 id="${"the-context"}">The Context</h3><a href="${"#the-context"}"><span class="${"icon icon-link"}"></span></a>
<p>In a SaaS product I work on, we allow users to perform actions on a large data set. Naturally, such processing can sometimes take a while and we do not want our users held up by a long-running request. So, I send a request with a filter object denoting which items in the data set should be processed, a job gets created, and a <code>jobId</code> is returned. I use that <code>jobId</code> to poll an endpoint every few seconds to get the status of the job. If the job status is “pending” or “in_progress”, I continue polling. If it fails, I stop polling and display an error message. If it completes successfully, I show a quick “snackbar” message to the user that the job has completed.</p>
<h3 id="${"the-usage"}">The Usage</h3><a href="${"#the-usage"}"><span class="${"icon icon-link"}"></span></a>
<p>I am a big fan of <a href="${"https://ngrx.io/guide/component-store"}" rel="${"nofollow"}">NgRx Component Store</a> and use it extensively in my projects. In the example below, you can see I consume the custom <code>pollUntil</code> operator just like any other “pipeable” RxJS operator.</p>
<pre class="${"language-typescript"}"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">readonly</span> queryJobStatus <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>jobId$<span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> jobId$<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
    <span class="token function">switchMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>jobId<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>jobService<span class="token punctuation">.</span><span class="token function">getJobStatus</span><span class="token punctuation">(</span>jobId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
        <span class="token generic-function"><span class="token function">pollUntil</span><span class="token generic class-name"><span class="token operator">&lt;</span>JobCreationResponse<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">3_000</span><span class="token punctuation">,</span> pollUntilPredicateHandler<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">tapResponse</span><span class="token punctuation">(</span>
          <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleJobComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">(</span>error<span class="token operator">:</span> HttpErrorResponse<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">handleJobError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>Note that we can give it an interface that describes the shape of the response, we can specify the polling interval in milliseconds, and we pass in a predicate handler. The predicate handler is what determines when the polling will stop.</p>
<p><em>Note: Did you know in modern JS, you can separate numbers with an underscore to make them more readable? In the example above, JS understands 3_000 to be 3000.</em></p>
<h3 id="${"under-the-hood"}">Under the Hood</h3><a href="${"#under-the-hood"}"><span class="${"icon icon-link"}"></span></a>
<pre class="${"language-typescript"}"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pollUntil</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>pollInterval<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token function-variable function">responsePredicate</span><span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>source$<span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">timer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> pollInterval<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
      <span class="token function">switchMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> source$<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">first</span><span class="token punctuation">(</span>responsePredicate<span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>As you can see, I use generics to allow the consumer to specify the type of their source observable and I create a timer that emits on the interval the consumer provides. When the timer emits, the <code>switchMap</code> subscribes to the <code>source$</code> observable and because our source in this case is a <code>HttpClient</code> request, the request is made each time the timer emits.</p>
<p>The <code>first</code> RxJS operator emits only the first value that meets the condition specified in the predicate passed into it. You will likely need to write your own predicate here and pass it into the operator because it is specific to your API response. Below is an example of mine.</p>
<pre class="${"language-typescript"}"><!-- HTML_TAG_START -->${`<code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pollUntilPredicateHandler</span><span class="token punctuation">(</span>response<span class="token operator">:</span> PollingOperationResponseData<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> AsyncJobState<span class="token punctuation">.</span>completed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// success - stop polling</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> AsyncJobState<span class="token punctuation">.</span>failed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>$localize<span class="token template-string"><span class="token template-punctuation string">&#96;</span><span class="token string">Job failed.</span><span class="token template-punctuation string">&#96;</span></span><span class="token punctuation">)</span> <span class="token comment">// error - stop polling</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// continue polling</span>
<span class="token punctuation">&#125;</span></code>`}<!-- HTML_TAG_END --></pre>
<p>In my predicate, I check to see if the job is complete. If it is, I return <code>true</code> and it completes the observable stream and polling stops. If the job fails, I throw an error, which also completes the observable stream and the polling stops. If I return false, the polling continues.</p>
<p>Note: Because I want this to be reusable, the error message is intentionally vague. Referring back to my first example, it’s up to the consumer to catch the error and handle it respective to each use case.</p>
<h3 id="${"watch-out-for-this"}">Watch out for this</h3><a href="${"#watch-out-for-this"}"><span class="${"icon icon-link"}"></span></a>
<p>Notice that the <code>pollUntil</code> operator uses <code>switchMap</code> under the hood. That means if the interval is too short and emits again before we get a response, the previous request will be effectively canceled and the new request will be made. This isn’t a big deal if it happens only rarely, but if your response time is always slower than your interval time, you could find yourself in an infinite loop where polling never stops.</p>
<p>Another thing worth noting is that this is intended for “reading” data, not for “writing” data. Because <code>switchMap</code> unsubscribes from the previous inner observable and subscribes to a new inner observable when the source observable emits, you cannot be sure if the “write” actually happened or not. This can cause front-end state and back-end state to get out of sync. A general best practice is to use <code>switchMap</code> for reads and <code>concatMap</code> or <code>exhaustMap</code> for writes.</p>`;
});
export {
  Polling_http_angular_rxjs as default,
  metadata
};
